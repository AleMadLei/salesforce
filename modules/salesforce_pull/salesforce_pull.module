<?php

define('SALESFORCE_PULL_QUEUE', 'salesforce_pull');

/**
 * Implements hook_menu().
 */
function salesforce_pull_menu() {
  $items['admin/config/services/salesforce/testing'] = array(
    'title' => 'Salesforce Testing Page',
    'page callback' => 'salesforce_pull_page',
    'access callback' => 'salesforce_mappings_access',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/*
 * Implements hook_cron()
 */
function salesforce_pull_cron() {
  salesforce_pull_get_updated_records();
  salesforce_pull_process_records();
}

/*
 * Pull updated records and place them in the queue.
 */
function salesforce_pull_get_updated_records() {
  $sfapi = salesforce_get_api();
  $queue = DrupalQueue::get(SALESFORCE_PULL_QUEUE);

  foreach (salesforce_mapping_get_mapped_objects() as $type) {
    // Get field list from mappings
    foreach (salesforce_mapping_load_multiple(array('salesforce_object_type' => $type)) as $mapping) {
      foreach ($mapping->field_mappings as $field_map) {
        $mapped_fields[$field_map['salesforce_field']] = $field_map['salesforce_field'];
      }
    }
    $fields = 'Id';
    foreach ($mapped_fields as $field) {
      $fields .= ',+' . $field;
    }
    $queryString = 'SELECT+'. $fields .'+from+' . $type;
    $sf_last_sync = variable_get('salesforce_pull_last_sync_' . $type, NULL);
    // If no lastupdate, get all records, else get records since last pull
    if ($sf_last_sync) {
      $last_sync = gmdate('Y-m-d\TH:i:s\Z', $sf_last_sync);
      $queryString .= '+where+LastModifiedDate>' . $last_sync;
    }

    // SOQL Query
    // TODO: Handle error. Maybe try / catch.
    $results = $sfapi->query($queryString);


    // Handle requests larger than the batch limit (usually 2000)
//    // TODO: Don't hardcode version/URL. Consider pulling this out and let calling code handle the nextRecordsURL.
//    $next_records_url = isset($new_result['nextRecordsUrl']) ?
//      str_replace('/services/data/v25.0/', '', $results['nextRecordsUrl']) :
//      FALSE;
//    while($next_records_url) {
//      $new_result = $this->apiCall($next_records_url);
//      $result['records'] = array_merge($results['records'], $new_result['records']);
//      $next_records_url = isset($new_result['nextRecordsUrl']) ?
//        str_replace('/services/data/v25.0/', '', $new_result['nextRecordsUrl']) : FALSE;
//    }
//



    // Write items to the queue
    foreach ($results['records'] as $result) {
      $queue->createItem($result);
    }

    variable_set('salesforce_pull_last_sync_' . $type, REQUEST_TIME);
  }
}

/*
 * Process records in the queue.
 */
function salesforce_pull_process_records() {
  $sfapi = salesforce_get_api();
  $limit = variable_get('salesforce_pull_limit', 50);

  $queue = DrupalQueue::get(SALESFORCE_PULL_QUEUE);
  for ($stop = 0; ($item = $queue->claimItem()) && $stop < $limit; $stop++) {
    // Get Salesforce object
    $sf_object = $item->data;//$sfapi->objectRead($item->data['attributes']['type'], $item->data['Id']);

    // Get Mapping
    $sf_mappings = salesforce_mapping_load_multiple(
      array('salesforce_object_type' => $sf_object['attributes']['type'])
    );

    foreach ($sf_mappings as $sf_mapping) {
      // Mapping object exists?
      $mapping_object = salesforce_mapping_object_load_by_sfid($sf_object['Id']);
      if ($mapping_object && ($sf_mapping->sync_triggers & SALESFORCE_MAPPING_SYNC_SF_UPDATE)) {
        $entity = entity_load_single($mapping_object->entity_type, array($mapping_object->entity_id));
        $entity_updated = $entity->updated;
        $sf_object_updated = strtotime($sf_object['LastModifiedDate']);
        if ($sf_object_updated > $entity_updated) {
          // Field Mapping
          foreach ($sf_mapping->field_mappings as $field_map) {
            $entity->$field_map['drupal_field'] = $sf_object[$field_map['salesforce_field']];
          }
          entity_save($mapping_object->entity_type, $entity);
          watchdog('Salesforce Pull',
            'Updated entity %label associated with Salesforce Object ID: %id',
            array(
              '%label' => $entity->label(),
              '%id' => $sf_object['Id']
            )
          );
        }
      }
      else if ($sf_mapping->sync_triggers & SALESFORCE_MAPPING_SYNC_SF_CREATE) {
        // Create entity from mapping object and field maps.
        $entity_info = entity_get_info($sf_mapping->drupal_entity_type);
        $values = array($entity_info['entity keys']['bundle'] => $sf_mapping->drupal_bundle);
        foreach ($sf_mapping->field_mappings as $field_map) {
          $values[$field_map['drupal_field']] = $sf_object[$field_map['salesforce_field']];
        }

        $entity = entity_create($sf_mapping->drupal_entity_type, $values);

        entity_save($sf_mapping->drupal_entity_type, $entity);
        watchdog('Salesforce Pull',
          'Created entity %label associated with Salesforce Object ID: %id',
          array(
            '%label' => $entity->label(),
            '%id' => $sf_object['Id']
          )
        );

        $mapping_object = entity_create('salesforce_mapping_object', array(
          'salesforce_id' => $sf_object['Id'],
          'entity_type' => $sf_mapping->drupal_entity_type,
          'entity_id' => $entity->internalIdentifier(),
        ));
        $mapping_object->save();
      }
    }
    // Remove item from queue
    $queue->deleteItem($item);
  }

  // If we have reached the pull limit and an item is still claimed, release it
  if ($item) {
    $queue->releaseItem($item);
  }
}

function salesforce_pull_page() {

  return '';
}
